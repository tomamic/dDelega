package it.unipr.ddelega.samldd;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Security;
import java.security.interfaces.DSAPublicKey;
import java.security.interfaces.RSAPublicKey;

import org.bouncycastle.util.encoders.Base64;
import org.opensaml.Configuration;
import org.opensaml.DefaultBootstrap;
/* CODE FOR NEW OPENSAML VERSIONS
import org.opensaml.DefaultBootstrap;
//*/
import org.opensaml.common.IdentifierGenerator;
import org.opensaml.common.impl.SecureRandomIdentifierGenerator;
import org.opensaml.xml.validation.ValidatorSuite;

/**
 * Helper class to provide a simple implementation of common operations needed to build SPKI certificates.
 * 
 * @author Thomas Florio
 */
public class SamlddHelper {

	protected static boolean initialized = false;

	/** Initialize the SPKI library */
	public static void init()
	{
		if (!initialized) {
			try {
				// Initialize OpenSAML
				DefaultBootstrap.bootstrap();
				//Configuration.registerObjectProvider(XACMLPolicyStatement.DEFAULT_ELEMENT_NAME, new XACMLPolicyStatementBuilder(), new XACMLPolicyStatementMarshaller(), new XACMLPolicyStatementUnmarshaller(), null);

				//ValidatorSuite suite = new ValidatorSuite("xacml-saml");
				//suite.registerValidator(XACMLPolicyStatement.DEFAULT_ELEMENT_NAME, new XACMLPolicyStatementSchemaValidator());

				//Configuration.registerValidatorSuite("xacml-saml", suite, null);

				// Add the security provider
				Provider provider = new SamlddProvider();
				Security.addProvider(provider);
				initialized = true;
			} catch(Exception e) {
				throw new RuntimeException( "FATAL: Unable to initialize SPKI library", e );
			}
		}
	}

	/**
	 * Creates and returns a random identifier. It returns a string rapresenting a 128-bit number generated from a
	 * {@link java.security.SecureRandom} source.
	 * 
	 * @return the generate random string.
	 */
	public static String getRandomIdentifier()
	{
		IdentifierGenerator randomNumber = null;
		try {
			randomNumber = new SecureRandomIdentifierGenerator();
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return randomNumber.generateIdentifier();
	}

	/**
	 * Creates and returns a string rapresenting a random identifier with the specified prefix. The format of the string
	 * is the base, followed by a '-' and a 128-bit random number, generated from a {@link java.security.SecureRandom} 
	 * source.
	 * 
	 * @param base the prefix of the identifier.
	 * @return the generated random string. 
	 */
	public static String getRandomIdentifier( String base )
	{
		IdentifierGenerator randomNumber = null;
		try {
			randomNumber = new SecureRandomIdentifierGenerator();
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return base + "-" + randomNumber.generateIdentifier();
	}

	/**
	 * Creates and returns a string rapresentig the hash of the given public key. The hash value is encoded using
	 * the Base64 algorithm and it has the form "ALGORITHM:hashvalue"
	 * 
	 * @param key the public key to be hashed.
	 * @param algo the hashing algorithm to be used to compute the hash.  
	 * @return the generated hash string. <code>null</code> if the key type is not supported.
	 * @throws NoSuchAlgorithmException when the chosen algorithm is not available.
	 */
	public static String hashPublicKey( PublicKey key, String algo ) throws NoSuchAlgorithmException
	{
		// Create the message digest using standard crypto APIs
		MessageDigest md = MessageDigest.getInstance( algo );

		// Creates the digest over the public key string generated by the method writePublicKey()
		String publicKey = writePublicKey( key );
		// If it's null the key type is not supported
		if( publicKey == null )
			return null;

		byte[] hash = md.digest( publicKey.getBytes() );

		// Encode the Hash in BASE64
		hash = Base64.encode( hash );	
		return algo.toUpperCase() + ":" + new String( hash );
	}

	/** Check if the given strinf is the hash of a public key 
	 * 
	 * @param str the string to be checked.
	 * @return <code>true</code> if it's a keyHash generated with {@link SamlddHelper#hashPublicKey(PublicKey, String)} 
	 */
	public static boolean isKeyHash( String str )
	{
		// Check if there is exacly only one ':'
		if( str.indexOf( ':' ) == -1 || str.indexOf( ':' ) != str.lastIndexOf( ':' ) )
			return false;	

		// Check if the text until the ':' is all uppercase
		String algo = str.substring( 0, str.indexOf( ':' ) );
		if( !algo.equals( algo.toUpperCase() ) )
			return false;

		// Check the paddings '=' at end if are present
		int length = str.length();
		if( str.endsWith( "=" ) || str.endsWith( "==" ) )
		{
			length = str.indexOf( '=' );
			// Check there aren't more than 2 char after the new end position
			if( str.length() - length > 2 )
				return false;
		}

		// Check if the text after is in Base64
		String base64Valid =  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		for( int i = str.indexOf( ':' ) + 1; i < length; i++ )
			if( base64Valid.indexOf( str.charAt( i ) ) == -1  )
				return false;

		return true;
	}

	/**
	 * Returns the hashing algoritm name used in this key hash.
	 * 
	 * @param keyHash the hash to check.
	 * @return the algorithm used to make the hash.
	 */
	public static String getHashingAlgorithm( String keyHash )
	{
		if( ! isKeyHash( keyHash ))
			return null;
		else
			return keyHash.substring( 0, keyHash.indexOf( ':' ) );
	}


	/**
	 * Creates and return a string containing the public key encoded with the BASE64 algorithm. The format of the string
	 * is "KEYTYPE:keyvalue".
	 * 
	 * @param key the public key.
	 * @return the string rapresenting the key. <code>null</code> if the key type is not supported.
	 */
	public static String writePublicKey( PublicKey key )
	{
		if( key.getAlgorithm().equals( "RSA" ) )
		{
			RSAPublicKey rsaKey = (RSAPublicKey) key;
			// Encode in BASE64 the public exponent and the modulus
			byte[] pe64 = Base64.encode( rsaKey.getPublicExponent().toByteArray() );
			byte[] mod64 = Base64.encode( rsaKey.getModulus().toByteArray() );
			return "RSA:" + new String( pe64 ) + "|" + new String( mod64 ); 
		}

		if( key.getAlgorithm().equals( "DSA" ) )
		{
			DSAPublicKey dsaKey = (DSAPublicKey) key;
			// Encode g, p, q, y with BASE64
			byte[] g64 = Base64.encode( dsaKey.getParams().getG().toByteArray() );
			byte[] p64 = Base64.encode( dsaKey.getParams().getP().toByteArray() );
			byte[] q64 = Base64.encode( dsaKey.getParams().getQ().toByteArray() );
			byte[] y64 = Base64.encode( dsaKey.getY().toByteArray() );

			return "KEY:DSA:" + new String( g64 ) + "|" + new String( p64 ) + "|" + new String( q64 ) + "|" + new String( y64 );
		}

		return null;
	}


	/**
	 * Creates a fully qualified SPKI name from namespace qualifier and local name.
	 * 
	 * @param qualifier the namespace that the local name belong to.
	 * @param local the local name.
	 * @return a string rapresenting the fully qualified name.
	 */
	public static String createFullyQualifiedName( String qualifier, String local )
	{
		return qualifier.trim() + " " + local.trim();
	}

	/**
	 * Gets the qualifier from the given fully qualified name.
	 * 
	 * @param qname the fully qualified name. 
	 * @return the namespace qualifier.
	 */
	public static String getQualfierFromFullyQualified( String qname )
	{
		return qname.substring( 0, qname.indexOf( ' ' ) );
	}

	/**
	 * Gets the local name from the given fully qualified name.
	 * 
	 * @param qname the fully qualified name.
	 * @return the local name.
	 */
	public static String getLocalNameFromFullyQuString( String qname )
	{
		return qname.substring( qname.indexOf( ' ' ) );
	}

}
